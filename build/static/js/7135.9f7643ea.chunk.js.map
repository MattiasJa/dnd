{"version":3,"file":"static/js/7135.9f7643ea.chunk.js","mappings":"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","sources":["../node_modules/@umetrics/sartorius-ui-utils/src/resizeObserverError/index.ts","../node_modules/tslib/tslib.es6.mjs","../node_modules/@lit-labs/virtualizer/src/events.ts","../node_modules/@lit-labs/virtualizer/src/ScrollerController.ts","../node_modules/@lit-labs/virtualizer/src/Virtualizer.ts","../node_modules/@lit-labs/virtualizer/src/virtualize.ts","../node_modules/@lit-labs/virtualizer/src/LitVirtualizer.ts","../node_modules/@lit-labs/virtualizer/src/lit-virtualizer.ts"],"sourcesContent":["function interceptMethod(target, methodName, interceptor) {\n    const originalMethod = target[methodName];\n    const newMethod = (...args) => interceptor.bind(target)(originalMethod, ...args);\n    Object.assign(target, { [methodName]: newMethod });\n    return () => {\n        if (target[methodName] !== newMethod) {\n            throw new Error(\n                `Unexpected method \"${methodName}\" on ${target} likely due to out-of-sequence interceptor teardown.`\n            );\n        }\n        Object.assign(target, { [methodName]: originalMethod });\n        return originalMethod;\n    };\n}\n\nfunction isResizeObserverLoopErrorMessage(message) {\n    return (\n        message.includes('ResizeObserver loop limit exceeded') ||\n        message.includes('ResizeObserver loop completed with undelivered notifications')\n    );\n}\n\nfunction ignoreWindowOnError(messagePredicate) {\n    return interceptMethod(window, 'onerror', (originalOnError, ...args) => {\n        const message = typeof args[0] === 'string' ? args[0] : args[0]?.message;\n        if (messagePredicate(message)) {\n            return;\n        }\n        return originalOnError?.apply(window, args);\n    });\n}\n\nfunction ignoreWindowResizeObserverLoopErrors() {\n    return ignoreWindowOnError(isResizeObserverLoopErrorMessage);\n}\n\nfunction preventResizeObserverLoopErrorEventDefaults() {\n    const eventListener = (ev) => {\n        if (typeof ev.message === 'string' && isResizeObserverLoopErrorMessage(ev.message)) {\n            ev.preventDefault?.();\n            ev.stopPropagation?.();\n            ev.stopImmediatePropagation?.();\n        }\n    };\n    const removeEventListener = () => window.removeEventListener('error', eventListener);\n    window.addEventListener('error', eventListener);\n    // Returns a function that can be used to remove the event listener.\n    return removeEventListener;\n}\n\nlet singletonPreventResizeObserverError: (() => void) | null;\nexport const preventResizeObserverError = (): (() => void) | null => {\n    if (!singletonPreventResizeObserverError) {\n        const i0 = preventResizeObserverLoopErrorEventDefaults();\n        const i1 = ignoreWindowResizeObserverLoopErrors();\n        singletonPreventResizeObserverError = () => {\n            i0();\n            i1();\n            singletonPreventResizeObserverError = null;\n        };\n        return singletonPreventResizeObserverError;\n    }\n    return null;\n};\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport class RangeChangedEvent extends Event {\n  static eventName = 'rangeChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(RangeChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class VisibilityChangedEvent extends Event {\n  static eventName = 'visibilityChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(VisibilityChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class UnpinnedEvent extends Event {\n  static eventName = 'unpinned';\n\n  constructor() {\n    super(UnpinnedEvent.eventName, {bubbles: false});\n  }\n}\n\ninterface Range {\n  first: number;\n  last: number;\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ScrollToCoordinates} from './layouts/shared/Layout.js';\n\ntype retargetScrollCallback = () => ScrollToCoordinates;\ntype endScrollCallback = () => void;\ntype Nullable<T> = T | null;\n\nexport class ScrollerShim {\n  protected _node: Element | Window;\n  protected _element: Nullable<Element> = null;\n\n  constructor(element?: Element) {\n    const node = element ?? window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n\n  public get element() {\n    return (\n      this._element || document.scrollingElement || document.documentElement\n    );\n  }\n\n  public get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n\n  public get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n\n  public get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n\n  public get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n\n  public get viewportHeight() {\n    return this._element\n      ? this._element.getBoundingClientRect().height\n      : window.innerHeight;\n  }\n\n  public get viewportWidth() {\n    return this._element\n      ? this._element.getBoundingClientRect().width\n      : window.innerWidth;\n  }\n\n  public get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n\n  public get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\n\nexport class ScrollerController extends ScrollerShim {\n  private _originalScrollTo:\n    | typeof Element.prototype.scrollTo\n    | typeof window.scrollTo;\n  private _originalScrollBy:\n    | typeof Element.prototype.scrollBy\n    | typeof window.scrollBy;\n  private _originalScroll:\n    | typeof Element.prototype.scroll\n    | typeof window.scroll;\n  private _clients = new Set<unknown>();\n  private _retarget: Nullable<retargetScrollCallback> = null;\n  private _end: Nullable<endScrollCallback> = null;\n  private __destination: Nullable<ScrollToOptions> = null;\n\n  constructor(client: unknown, element?: Element) {\n    super(element);\n\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n\n    const node = this._node;\n\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n\n  public correctingScrollError = false;\n\n  private get _destination() {\n    return this.__destination;\n  }\n\n  public get scrolling() {\n    return this._destination !== null;\n  }\n\n  public scrollTo(options: ScrollToOptions): void;\n  public scrollTo(x: number, y: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    this._scrollTo(options);\n  }\n\n  public scrollBy(options: ScrollToOptions): void;\n  public scrollBy(x: number, y: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n\n  private _nativeScrollTo(options: ScrollToOptions) {\n    this._originalScrollTo!.bind(this._element || window)(options);\n  }\n\n  private _scrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback | null = null,\n    end: endScrollCallback | null = null\n  ) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n\n  private _setDestination(options: ScrollToOptions) {\n    let {top, left} = options;\n    top =\n      top === undefined\n        ? undefined\n        : Math.max(0, Math.min(top, this.maxScrollTop));\n    left =\n      left === undefined\n        ? undefined\n        : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (\n      this._destination !== null &&\n      left === this._destination.left &&\n      top === this._destination.top\n    ) {\n      return false;\n    }\n    this.__destination = {top, left, behavior: 'smooth'};\n    return true;\n  }\n\n  private _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n\n  private _updateManagedScrollTo(coordinates: ScrollToCoordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n\n  public managedScrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback,\n    end: endScrollCallback\n  ) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n\n  public correctScrollError(coordinates: ScrollToCoordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => (this.correctingScrollError = false))\n    );\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n\n  private _checkForArrival() {\n    if (this._destination !== null) {\n      const {scrollTop, scrollLeft} = this;\n      let {top, left} = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n\n  public detach(client: unknown) {\n    this._clients.delete(client);\n\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n\n  private _attach(client: unknown) {\n    this._clients.add(client);\n\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client – otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  StateChangedMessage,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  LayoutHostMessage,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver: typeof ResizeObserver | undefined =\n  typeof window !== 'undefined' ? window.ResizeObserver : undefined;\n\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor: typeof ResizeObserver) {\n  _ResizeObserver = Ctor;\n}\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured = new Map<HTMLElement, unknown>();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet<Function>();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  /**\n   * Layout initialization is async because we dynamically load\n   * the default layout if none is specified. This state is to track\n   * whether init is complete.\n   */\n  private _layoutInitialized: Promise<void> | null = null;\n\n  /**\n   * Track connection state to guard against errors / unnecessary work\n   */\n  private _connected = false;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || ({} as BaseLayoutConfig);\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n\n  private _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    this._hostElementRO = new _ResizeObserver!(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new _ResizeObserver!(\n      this._childrenSizeChanged.bind(this)\n    );\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n    this._connected = true;\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController?.detach(this);\n    this._scrollerController = null;\n    this._mutationObserver?.disconnect();\n    this._mutationObserver = null;\n    this._hostElementRO?.disconnect();\n    this._hostElementRO = null;\n    this._childrenRO?.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n    this._connected = false;\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  async updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      // The new config is compatible with the current layout,\n      // so we update the config and return true to indicate\n      // a successful update\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(\n      (message: LayoutHostMessage) => this._handleLayoutMessage(message),\n      config\n    );\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM(state: StateChangedMessage) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n\n  _finishDOMUpdate() {\n    if (this._connected) {\n      // _childrenRO should be non-null if we're connected\n      this._children.forEach((child) => this._childrenRO!.observe(child));\n      this._checkScrollIntoViewTarget(this._childrenPos);\n      this._positionChildren(this._childrenPos);\n      this._sizeHostElement(this._scrollSize);\n      this._correctScrollError();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  _updateLayout() {\n    if (this._layout && this._connected) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  _handleLayoutMessage(message: LayoutHostMessage) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement!.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr: Array<HTMLElement> = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = Math.max(0, bottom - top);\n      const width = Math.max(0, right - left);\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout?.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors: Array<HTMLElement> = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter((a) => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {TemplateResult, ChildPart, html, noChange} from 'lit';\nimport {directive, DirectiveResult, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {repeat, KeyFn} from 'lit/directives/repeat.js';\nimport {Virtualizer} from './Virtualizer.js';\nimport {RangeChangedEvent} from './events.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\n\nexport {virtualizerRef, VirtualizerHostElement} from './Virtualizer.js';\n\n/**\n * Configuration options for the virtualize directive.\n */\nexport interface VirtualizeDirectiveConfig<T> {\n  /**\n   * A function that returns a lit-html TemplateResult. It will be used\n   * to generate the DOM for each item in the virtual list.\n   */\n  renderItem?: RenderItemFunction<T>;\n\n  keyFunction?: KeyFn<T>;\n\n  scroller?: boolean;\n\n  // TODO (graynorton): Document...\n  layout?: LayoutConfigValue;\n\n  /**\n   * The list of items to display via the renderItem function.\n   */\n  items?: Array<T>;\n}\n\nexport type RenderItemFunction<T = unknown> = (\n  item: T,\n  index: number\n) => TemplateResult;\n\nexport const defaultKeyFunction: KeyFn<unknown> = (item: unknown) => item;\nexport const defaultRenderItem: RenderItemFunction<unknown> = (\n  item: unknown,\n  idx: number\n) => html`${idx}: ${JSON.stringify(item, null, 2)}`;\n\nclass VirtualizeDirective<T = unknown> extends AsyncDirective {\n  _virtualizer: Virtualizer | null = null;\n  _first = 0;\n  _last = -1;\n  _renderItem: RenderItemFunction<T> = (item: T, idx: number) =>\n    defaultRenderItem(item, idx + this._first);\n  _keyFunction: KeyFn<T> = (item: T, idx: number) =>\n    defaultKeyFunction(item, idx + this._first);\n  _items: Array<T> = [];\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.CHILD) {\n      throw new Error(\n        'The virtualize directive can only be used in child expressions'\n      );\n    }\n  }\n\n  render(config?: VirtualizeDirectiveConfig<T>) {\n    if (config) {\n      this._setFunctions(config);\n    }\n    const itemsToRender: Array<T> = [];\n\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i <= this._last; i++) {\n        itemsToRender.push(this._items[i]);\n      }\n    }\n    return repeat(itemsToRender, this._keyFunction, this._renderItem);\n  }\n\n  update(part: ChildPart, [config]: [VirtualizeDirectiveConfig<T>]) {\n    this._setFunctions(config);\n    const itemsChanged = this._items !== config.items;\n    this._items = config.items || [];\n    if (this._virtualizer) {\n      this._updateVirtualizerConfig(part, config);\n    } else {\n      this._initialize(part, config);\n    }\n    return itemsChanged ? noChange : this.render();\n  }\n\n  private async _updateVirtualizerConfig(\n    part: ChildPart,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    const compatible = await this._virtualizer!.updateLayoutConfig(\n      config.layout || {}\n    );\n    if (!compatible) {\n      const hostElement = part.parentNode as HTMLElement;\n      this._makeVirtualizer(hostElement, config);\n    }\n    this._virtualizer!.items = this._items;\n  }\n\n  private _setFunctions(config: VirtualizeDirectiveConfig<T>) {\n    const {renderItem, keyFunction} = config;\n    if (renderItem) {\n      this._renderItem = (item, idx) => renderItem(item, idx + this._first);\n    }\n    if (keyFunction) {\n      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);\n    }\n  }\n\n  private _makeVirtualizer(\n    hostElement: HTMLElement,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n    const {layout, scroller, items} = config;\n    this._virtualizer = new Virtualizer({hostElement, layout, scroller});\n    this._virtualizer.items = items;\n    this._virtualizer.connected();\n  }\n\n  private _initialize(part: ChildPart, config: VirtualizeDirectiveConfig<T>) {\n    const hostElement = part.parentNode as HTMLElement;\n    if (hostElement && hostElement.nodeType === 1) {\n      hostElement.addEventListener('rangeChanged', (e: RangeChangedEvent) => {\n        this._first = e.first;\n        this._last = e.last;\n        this.setValue(this.render());\n      });\n      this._makeVirtualizer(hostElement, config);\n    }\n  }\n\n  disconnected() {\n    this._virtualizer?.disconnected();\n  }\n\n  reconnected() {\n    this._virtualizer?.connected();\n  }\n}\n\nexport const virtualize = directive(VirtualizeDirective) as <T>(\n  config?: VirtualizeDirectiveConfig<T>\n) => DirectiveResult<typeof VirtualizeDirective>;\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {html, LitElement} from 'lit';\nimport {property} from 'lit/decorators/property.js';\nimport {KeyFn} from 'lit/directives/repeat.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\nimport {\n  virtualize,\n  virtualizerRef,\n  VirtualizerHostElement,\n  defaultRenderItem,\n  defaultKeyFunction,\n  RenderItemFunction,\n} from './virtualize.js';\n\nexport class LitVirtualizer<T = unknown> extends LitElement {\n  @property({attribute: false})\n  items: T[] = [];\n\n  @property()\n  renderItem: RenderItemFunction<T> = defaultRenderItem;\n\n  @property()\n  keyFunction: KeyFn<T> = defaultKeyFunction;\n\n  @property({attribute: false})\n  layout: LayoutConfigValue = {};\n\n  @property({reflect: true, type: Boolean})\n  scroller = false;\n\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    const {items, renderItem, keyFunction, layout, scroller} = this;\n    return html`${virtualize({\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller,\n    })}`;\n  }\n\n  element(index: number) {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.element(index);\n  }\n\n  get layoutComplete() {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.layoutComplete;\n  }\n\n  /**\n   * This scrollToIndex() shim is here to provide backwards compatibility with other 0.x versions of\n   * lit-virtualizer. It is deprecated and will likely be removed in the 1.0.0 release.\n   */\n  scrollToIndex(\n    index: number,\n    position: 'start' | 'center' | 'end' | 'nearest' = 'start'\n  ) {\n    this.element(index)?.scrollIntoView({block: position});\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {LitVirtualizer} from './LitVirtualizer.js';\nexport {LitVirtualizer};\nexport {RangeChangedEvent, VisibilityChangedEvent} from './events.js';\n\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\ncustomElements.define('lit-virtualizer', LitVirtualizer);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'lit-virtualizer': LitVirtualizer;\n  }\n}\n"],"names":["isResizeObserverLoopErrorMessage","message","includes","ignoreWindowOnError","messagePredicate","target","methodName","interceptor","originalMethod","newMethod","_len","arguments","length","args","Array","_key","bind","Object","assign","Error","interceptMethod","window","originalOnError","_len2","_key2","_a","apply","singletonPreventResizeObserverError","preventResizeObserverError","i0","eventListener","ev","preventDefault","call","_b","stopPropagation","_c","stopImmediatePropagation","addEventListener","removeEventListener","preventResizeObserverLoopErrorEventDefaults","i1","__decorate","decorators","key","desc","d","c","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","create","SuppressedError","RangeChangedEvent","Event","constructor","range","super","eventName","bubbles","this","first","last","VisibilityChangedEvent","UnpinnedEvent","ScrollerShim","element","_element","node","_node","document","scrollingElement","documentElement","scrollTop","scrollY","scrollLeft","scrollX","scrollHeight","scrollWidth","viewportHeight","getBoundingClientRect","height","innerHeight","viewportWidth","width","innerWidth","maxScrollTop","maxScrollLeft","ScrollerController","client","_clients","Set","_retarget","_end","__destination","correctingScrollError","_checkForArrival","_updateManagedScrollTo","scrollTo","scrollBy","_originalScrollTo","_originalScrollBy","_originalScroll","scroll","_attach","_destination","scrolling","p1","p2","options","left","top","_scrollTo","undefined","_nativeScrollTo","retarget","end","behavior","_setDestination","_resetScrollState","Math","max","min","coordinates","managedScrollTo","correctScrollError","requestAnimationFrame","topDiff","abs","leftDiff","detach","delete","size","add","_ResizeObserver","ResizeObserver","virtualizerRef","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","config","_benchmarkStart","_layout","_clippingAncestors","_scrollSize","_scrollError","_childrenPos","_childMeasurements","_toBeMeasured","Map","_rangeChanged","_itemsChanged","_visibilityChanged","_scrollerController","_isScroller","_sizer","_hostElementRO","_childrenRO","_mutationObserver","_scrollEventListeners","_scrollEventListenerOptions","passive","_loadListener","_childLoaded","_scrollIntoViewTarget","_updateScrollIntoViewCoordinates","_items","_first","_last","_firstVisible","_lastVisible","_scheduled","WeakSet","_measureCallback","_measureChildOverride","_layoutCompletePromise","_layoutCompleteResolver","_layoutCompleteRejecter","_pendingLayoutComplete","_layoutInitialized","_connected","hostElement","_init","items","isArray","_schedule","_updateLayout","scroller","_initHostElement","layoutConfig","layout","_initLayout","_initObservers","MutationObserver","_finishDOMUpdate","_hostElementSizeChanged","_childrenSizeChanged","_hostElement","_applyVirtualizerStyles","connected","includeSelf","el","foundFixed","ancestors","parent","getParentElement","push","getElementAncestors","filter","a","style","getComputedStyle","position","overflow","getClippingAncestors","_observeAndListen","observe","childList","forEach","ancestor","_children","child","disconnected","disconnect","_rejectLayoutCompletePromise","display","contain","minHeight","_getSizer","sizer","querySelector","createElement","setAttribute","appendChild","margin","padding","visibility","fontSize","textContent","updateLayoutConfig","Ctor","type","copy","FlowLayout","_handleLayoutMessage","measureChildren","updateItemSizes","listenForChildLoadEvents","startBenchmarking","performance","now","stopBenchmarking","timeElapsed","virtualizationTime","getEntriesByName","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","idx","has","clear","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","getMargins","method","Promise","resolve","_updateDOM","state","scrollSize","_adjustRange","childPositions","scrollError","_notifyVisibility","_notifyRange","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","unpin","handleEvent","event","currentTarget","firstVisible","lastVisible","dispatchEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","bottom","right","hostElementBounds","ancestorBounds","map","unshift","bounds","scrollingElementBounds","offsetWithinScroller","totalScrollSize","viewportSize","viewportScroll","h","v","transform","minWidth","pos","_ref","index","xOffset","yOffset","boxSizing","_this","Infinity","scrollIntoView","_scrollElementIntoView","getScrollIntoViewCoordinates","pin","layoutComplete","reject","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","_resolveLayoutCompletePromise","changes","change","set","contentRect","value","float","parseFloat","NaN","Number","isNaN","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","defaultKeyFunction","item","defaultRenderItem","html","JSON","stringify","VirtualizeDirective","AsyncDirective","part","_virtualizer","_renderItem","_keyFunction","PartType","CHILD","render","_setFunctions","itemsToRender","repeat","update","itemsChanged","_updateVirtualizerConfig","_initialize","noChange","_makeVirtualizer","renderItem","keyFunction","setValue","reconnected","virtualize","directive","LitVirtualizer","LitElement","createRenderRoot","scrollToIndex","block","property","attribute","reflect","Boolean","customElements","define"],"sourceRoot":""}