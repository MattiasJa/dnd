{"version":3,"file":"static/js/8950.37b684e8.chunk.js","mappings":"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","sources":["../node_modules/@umetrics/sartorius-ui-composable-plot-engine/src/composablePlotEngine.ts","../node_modules/@umetrics/sartorius-ui-composable-plot-engine/src/composablePlotEngineStyle.ts","../node_modules/@umetrics/sartorius-ui-composable-plot-engine/src/metadata.ts"],"sourcesContent":["import {\n    BaseElement,\n    createClassName,\n    defineElement,\n    html,\n    ifDefined,\n    nothing,\n    property,\n} from '@umetrics/sartorius-ui-base';\nimport { version } from './metadata';\n\nimport type {\n    Axis as AxisT,\n    ComposablePlot as ComposablePlotT,\n    PartialScaleSettingsMap,\n    SVGBar as SVGBarT,\n    SVGGrid as SVGGridT,\n    SVGLine as SVGLineT,\n    SVGScatter as SVGScatterT,\n} from '@umetrics/sartorius-ui-composable-plot';\n\nimport type { Datum } from '@umetrics/sartorius-ui-plot-utils';\n\nimport { composablePlotEngineStyles } from './composablePlotEngineStyle';\nimport {\n    ComposablePlotEngineConfig,\n    ComposablePlotEngineFlexDataType,\n    ComposablePlotEngineProperties,\n} from './composablePlotEngineProperties';\n\n/* Experimental, dont use */\n\n@defineElement({ tagName: 'composable-plot-engine', styles: composablePlotEngineStyles, version })\nexport class ComposablePlotEngine extends BaseElement implements ComposablePlotEngineProperties {\n    private static ComposablePlot: typeof ComposablePlotT;\n    private static Axis: typeof AxisT;\n    private static SVGGrid: typeof SVGGridT;\n    private static SVGScatter: typeof SVGScatterT;\n    private static SVGLine: typeof SVGLineT;\n    private static SVGBar: typeof SVGBarT;\n\n    @property({\n        type: Object,\n        attribute: 'config',\n        reflect: true,\n        converter: {\n            fromAttribute: (value: string | null) => (value && JSON.parse(value)) || {},\n            toAttribute: (value: object) => JSON.stringify(value),\n        },\n    })\n    public config?: ComposablePlotEngineConfig;\n\n    @property()\n    data?: ComposablePlotEngineFlexDataType;\n\n    connectedCallback() {\n        ComposablePlotEngine.dynSubRegister(\n            [\n                {\n                    module: () => import('@umetrics/sartorius-ui-composable-plot'),\n                    elem: ['ComposablePlot', 'Axis', 'SVGGrid', 'SVGLine', 'SVGScatter', 'SVGBar'],\n                },\n            ],\n            () => {\n                super.connectedCallback();\n            }\n        );\n    }\n\n    protected render() {\n        const [baseClassName, rootClasses] = createClassName(this.tagName.toLowerCase(), {});\n        return html` <div class=\"${rootClasses}\">${this._parser(baseClassName)}</div>`;\n    }\n\n    private _parser = (baseClassName) => {\n        if (this.config) {\n            const { heading, watermark, main, scale } = this.config;\n            const scaleSettings: PartialScaleSettingsMap = Object.fromEntries(\n                scale.map(({ name, scaleType, domain, symmetric }) => {\n                    const gotData =\n                        !!main[0].serie && main[0].serie.some((t) => t.scaleX === name || t.scaleY === name);\n                    const setting: NonNullable<PartialScaleSettingsMap>[string] = {};\n                    if (scaleType || !gotData) {\n                        setting.scaleType = scaleType ?? 'linear';\n                    }\n\n                    if (domain || !gotData) {\n                        setting.domain = domain ?? [0, 1];\n                    }\n                    setting.symmetricDomain = !!symmetric;\n                    setting.padding = {\n                        type: 'pixel',\n                        start: 5,\n                        end: 5,\n                    };\n                    return [name, setting];\n                })\n            );\n            return html`\n                <${ComposablePlotEngine.ComposablePlot.tag}\n                    class=\"${baseClassName}-plot\"\n                    heading=\"${heading}\"\n                    watermark=\"${watermark}\"\n                    .scaleSettings=${scaleSettings}\n                    .backgroundColor=${main[0].backgroundColor}\n                    .backgroundOpacity=${main[0].backgroundOpacity}\n                >\n                    ${this._axis(baseClassName)}\n                    ${this._grid(baseClassName)}\n                    ${this._data(baseClassName)}\n                </${ComposablePlotEngine.ComposablePlot.tag}>\n            `;\n        }\n        return nothing;\n    };\n\n    private _axis = (baseClassName) => {\n        const { config } = this;\n        const main = config?.main; // main isArray and stacked plots not implemented!\n\n        if (config && main) {\n            return config.scale.map(({ name, orientation }) => {\n                const axis = main[0].axis!.find((a) => a.scaleName === name);\n                if (axis) {\n                    const { slot, scaleX, scaleY } =\n                        orientation === 'vertical'\n                            ? { slot: 'axis-y', scaleY: name }\n                            : { slot: 'axis-x', scaleX: name };\n\n                    return html`\n                        <${ComposablePlotEngine.Axis.tag}\n                            class=\"${baseClassName}-axis\"\n                            slot=${axis.flip ? slot + '2' : slot}\n                            label=${axis.label}\n                            orientation=\"${orientation}\"\n                            .axisColor=\"${axis.axisColor}\"\n                            .labelColor=\"${axis.labelColor}\"\n                            .tickColor=\"${axis.tickColor || axis.axisColor}\"\n                            scale-x=${scaleX}\n                            scale-y=${scaleY}\n                            flip=${!!axis.flip}\n                        ></${ComposablePlotEngine.Axis.tag}>\n                    `;\n                }\n                return nothing;\n            });\n        }\n        return nothing;\n    };\n\n    private _data = (baseClassName) => {\n        const main = this.config?.main; // main isArray and stacked plots not implemented!\n\n        if (main && Array.isArray(main) && main[0].serie) {\n            const barLen = main[0].serie.filter((s) => s.type === 'bar').length;\n            let barNo = 0;\n\n            return html`${main[0].serie.map(({ scaleX, scaleY, type, color, dataX, dataY, colorBy, groupBy }) => {\n                const plotData = this._getPlotData(dataX, dataY);\n\n                if (plotData) {\n                    let category;\n                    if (colorBy) {\n                        category = this._getData(colorBy);\n                    } else if (groupBy) {\n                        category = this._getData(groupBy);\n                    }\n                    const reformattedData = this._formatPlotData(\n                        dataX!,\n                        dataY!,\n                        plotData,\n                        groupBy ? category : undefined\n                    );\n\n                    if (type === 'line') {\n                        const normalizedData = Array.isArray(reformattedData[0]) ? reformattedData : [reformattedData];\n\n                        return normalizedData.map((group, index) => {\n                            const fill = typeof color === 'object' && category ? color[group[0].group ?? index] : color;\n\n                            return html`\n                                <${ComposablePlotEngine.SVGLine.tag}\n                                    class=\"${baseClassName}-line\"\n                                    .scaleX=${scaleX}\n                                    .scaleY=${scaleY}\n                                    .color=${ifDefined(fill)}\n                                    .data=${reformattedData}\n                                ></${ComposablePlotEngine.SVGLine.tag}>`;\n                        });\n                    } else if (type === 'scatter') {\n                        return html`\n                            <${ComposablePlotEngine.SVGScatter.tag}\n                                class=\"${baseClassName}-scatter\"\n                                .scaleX=${scaleX}\n                                .scaleY=${scaleY}\n                                .defaultStyle=${({ index }) => {\n                                    return {\n                                        fillColor:\n                                            typeof color === 'object' && category\n                                                ? color[category[index] + '']\n                                                : ifDefined(color),\n                                    };\n                                }}\n                                .data=${reformattedData}\n                            ></${ComposablePlotEngine.SVGScatter.tag}>`;\n                    } else if (type === 'line-scatter') {\n                        const normalizedData = Array.isArray(reformattedData[0]) ? reformattedData : [reformattedData];\n\n                        return normalizedData.map((group, index) => {\n                            const fill = typeof color === 'object' && category ? color[group[0].group ?? index] : color;\n\n                            return html`\n                                <${ComposablePlotEngine.SVGLine.tag}\n                                    class=\"${baseClassName}-line\"\n                                    .scaleX=${scaleX}\n                                    .scaleY=${scaleY}\n                                    .color=${ifDefined(fill)}\n                                    .data=${group}\n                                ></${ComposablePlotEngine.SVGLine.tag}>\n                                <${ComposablePlotEngine.SVGScatter.tag}\n                                    class=\"${baseClassName}-scatter\"\n                                    .scaleX=${scaleX}\n                                    .scaleY=${scaleY}\n                                    .defaultStyle=${{ fillColor: ifDefined(fill) }}\n                                    .data=${group}\n                                ></${ComposablePlotEngine.SVGScatter.tag}>\n                            `;\n                        });\n                    } else if (type === 'bar') {\n                        return html`\n                            <${ComposablePlotEngine.SVGBar.tag}\n                                class=\"${baseClassName}-bar\"\n                                .scaleX=${scaleX}\n                                .scaleY=${scaleY}\n                                .defaultStyle=${({ index }) => {\n                                    return {\n                                        fillColor:\n                                            colorBy && color\n                                                ? color[category[index] as number] // Date string?\n                                                : ifDefined(color),\n                                    };\n                                }}\n                                .data=${reformattedData}\n                                .group=${{\n                                    index: barNo++,\n                                    totalCount: barLen,\n                                    spacing: 2,\n                                    offsetY: undefined,\n                                }}\n                                .vertical=${false}\n                            ></${ComposablePlotEngine.SVGBar.tag}>`;\n                    }\n                }\n                return nothing;\n            })}`;\n        }\n        return nothing;\n    };\n\n    private _grid = (baseClassName) => {\n        const main = this.config?.main;\n        if (main && main[0]) {\n            const { mode, origin, color, originColor, densityX, densityY } = main[0].grid || {};\n            return mode\n                ? html`\n                    <${ComposablePlotEngine.SVGGrid.tag}\n                        class=\"${baseClassName}-grid\"\n                        .mode=${mode}\n                        .origin=${ifDefined(origin)}\n                        .color=${ifDefined(color)}\n                        .originColor=${ifDefined(originColor)}\n                        .densityX=${ifDefined(densityX)}\n                        .densityY=${ifDefined(densityY)}></${ComposablePlotEngine.SVGGrid.tag}>\n                `\n                : nothing;\n        }\n        return nothing;\n    };\n\n    private _getData(key): Datum[] {\n        if (key) {\n            if (this.data && this.data[key]) {\n                return this.data[key];\n            } else if (this.config && this.config.data && this.config[key]) {\n                return this.config.data[key];\n            }\n        }\n        return [];\n    }\n\n    private _getPlotData(dataX?: string, dataY?: string): { [key: string]: Datum[] } {\n        if (dataX && dataY) {\n            return {\n                [dataX]: this._getData(dataX),\n                [dataY]: this._getData(dataY),\n            };\n        }\n        return {};\n    }\n\n    private _formatPlotData(\n        scaleX: string,\n        scaleY: string,\n        plotData: { [key: string]: Datum }[] | { [key: string]: Datum[] },\n        groupBy?: Datum[]\n    ) {\n        if (Array.isArray(plotData[scaleX]) && Array.isArray(plotData[scaleY])) {\n            // If in object format { x: [], y: [] }, map it to [{x, y}]\n            const formattedData = plotData[scaleX].map((xValue, index) => ({\n                x: xValue,\n                y: plotData[scaleY][index],\n                group: groupBy ? groupBy[index] : null, // Attach group if provided\n            }));\n\n            return groupBy ? this._groupBy(formattedData) : formattedData;\n        } else if (\n            Array.isArray(plotData) &&\n            plotData.every((el) => typeof el === 'object' && el[scaleX] != null && el[scaleY] != null)\n        ) {\n            // already in the format [{x, y}]\n            const formattedData = plotData.map(({ [scaleX]: x, [scaleY]: y }, index) => ({\n                x,\n                y,\n                group: groupBy ? groupBy[index] : null, // Attach group if provided\n            }));\n\n            return groupBy ? this._groupBy(formattedData) : formattedData;\n        } else {\n            throw new Error('Invalid data format');\n        }\n    }\n\n    // Helper function to group data by the 'group' property\n    private _groupBy(data: { x: Datum; y: Datum; group: Datum | null }[]): { x: Datum; y: Datum; group? }[][] {\n        const groupedMap = new Map<Datum, { x: Datum; y: Datum; group? }[]>();\n\n        data.forEach(({ x, y, group }) => {\n            if (group == null) return; // Skip if no group defined\n            if (!groupedMap.has(group)) groupedMap.set(group, []);\n            groupedMap.get(group)!.push({ x, y, group });\n        });\n\n        return Array.from(groupedMap.values());\n    }\n}\n","import { css, cssSelector, GenerateStyles } from '@umetrics/sartorius-ui-base';\n\nexport const composablePlotEngineStyles: GenerateStyles = (tagName) => {\n    const { root } = cssSelector(tagName);\n\n    return [\n        css`\n            :host,\n            :host::before,\n            :host::after,\n            :host *,\n            :host *::before,\n            :host *::after {\n                box-sizing: border-box;\n            }\n\n            :host {\n                display: block;\n                width: 100%;\n                height: 100%;\n            }\n\n            ${root} {\n                display: block;\n                width: 100%;\n                height: 100%;\n            }\n        `,\n    ];\n};\n","/*\n * Metadata build info for package. Managed at build time by task tools/metadata.ts\n */\nexport const version = '0.0.0';\nexport const buildDate = '2021-02-02- 02:02:02.000';\n"],"names":["ComposablePlotEngine","ComposablePlotEngine_1","BaseElement","constructor","_parser","baseClassName","this","config","heading","watermark","main","scale","scaleSettings","Object","fromEntries","map","_ref","name","scaleType","domain","symmetric","gotData","serie","some","t","scaleX","scaleY","setting","symmetricDomain","padding","type","start","end","html","ComposablePlot","tag","backgroundColor","backgroundOpacity","_axis","_grid","_data","nothing","_ref2","orientation","axis","find","a","scaleName","slot","Axis","flip","label","axisColor","labelColor","tickColor","_a","Array","isArray","barLen","filter","s","length","barNo","_ref3","color","dataX","dataY","colorBy","groupBy","plotData","_getPlotData","category","_getData","reformattedData","_formatPlotData","undefined","group","index","fill","SVGLine","ifDefined","SVGScatter","_ref4","fillColor","SVGBar","_ref5","totalCount","spacing","offsetY","mode","origin","originColor","densityX","densityY","grid","SVGGrid","connectedCallback","dynSubRegister","module","elem","super","render","rootClasses","createClassName","tagName","toLowerCase","key","data","formattedData","xValue","x","y","_groupBy","every","el","_ref6","Error","groupedMap","Map","forEach","_ref7","has","set","get","push","from","values","__decorate","property","attribute","reflect","converter","fromAttribute","value","JSON","parse","toAttribute","stringify","defineElement","styles","root","cssSelector","css","version"],"sourceRoot":""}